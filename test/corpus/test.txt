==================
Simple function
==================

fn main() {
  print("Hello World!")
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list)
    body: (block
      (expression_statement
        (call_expression
          function: (identifier)
          arguments: (argument_list
            (string_literal)))))))

==================
Function with parameters and return type
==================

fn double(arg Int) Int {
  arg * 2
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list
      (parameter
        name: (identifier)
        type: (type_identifier)))
    return_type: (type_identifier)
    body: (block
      (expression_statement
        (binary_expression
          (identifier)
          (number_literal))))))

==================
Struct definition
==================

struct Vec3 {
  x Int
  y Int
  z Int
}

---

(source_file
  (struct_definition
    name: (type_identifier)
    (field
      name: (identifier)
      type: (type_identifier))
    (field
      name: (identifier)
      type: (type_identifier))
    (field
      name: (identifier)
      type: (type_identifier))))

==================
Union definition
==================

union Option(T) {
  none
  T
}

---

(source_file
  (union_definition
    name: (generic_type
      name: (type_identifier)
      (type_identifier))
    (union_case
      label: (identifier))
    (union_case
      label: (type_identifier))))

==================
Variable declarations with compound assignments
==================

fn test() {
  let mut x = 5
  x += 10
  x *= 2
  x ++= "suffix"
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list)
    body: (block
      (declaration
        name: (identifier)
        value: (number_literal))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal)))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal)))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (string_literal))))))

==================
Bitwise operations
==================

fn bitwise(a Int, b Int) Int {
  let x = a & b
  let y = a | b
  let z = a ^ b
  let w = ~a
  let l = a << 2
  let r = a >> 2
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list
      (parameter
        name: (identifier)
        type: (type_identifier))
      (parameter
        name: (identifier)
        type: (type_identifier)))
    return_type: (type_identifier)
    body: (block
      (declaration
        name: (identifier)
        value: (binary_expression
          (identifier)
          (identifier)))
      (declaration
        name: (identifier)
        value: (binary_expression
          (identifier)
          (identifier)))
      (declaration
        name: (identifier)
        value: (binary_expression
          (identifier)
          (identifier)))
      (declaration
        name: (identifier)
        value: (unary_expression
          (identifier)))
      (declaration
        name: (identifier)
        value: (binary_expression
          (identifier)
          (number_literal)))
      (declaration
        name: (identifier)
        value: (binary_expression
          (identifier)
          (number_literal))))))

==================
Bitwise compound assignments
==================

fn test() {
  let mut x = 10
  x &= 5
  x |= 3
  x ^= 7
  x <<= 2
  x >>= 1
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list)
    body: (block
      (declaration
        name: (identifier)
        value: (number_literal))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal)))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal)))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal)))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal)))
      (expression_statement
        (compound_assignment_expression
          left: (identifier)
          right: (number_literal))))))

==================
If expression
==================

fn check(n Int) String {
  if n % 2 == 0 {
    "Even"
  } else {
    "Odd"
  }
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list
      (parameter
        name: (identifier)
        type: (type_identifier)))
    return_type: (type_identifier)
    body: (block
      (if_expression
        condition: (binary_expression
          (binary_expression
            (identifier)
            (number_literal))
          (number_literal))
        consequence: (block
          (expression_statement
            (string_literal)))
        alternative: (block
          (expression_statement
            (string_literal))))))))

==================
For loop
==================

fn loop() {
  for 1..=5 |i| {
    print(i)
  }
}

---

(source_file
  (function_definition
    name: (identifier)
    parameters: (parameter_list)
    body: (block
      (for_expression
        iterable: (range_literal
          (number_literal)
          (number_literal))
        element: (identifier)
        body: (block
          (call_expression
            function: (identifier)
            arguments: (argument_list
              (identifier))))))))

==================
Actor definition
==================

actor Counter {
  count Int

  fn increment(self) {
    self.count += 1
  }
}

---

(source_file
  (actor_definition
    name: (type_identifier)
    (field
      name: (identifier)
      type: (type_identifier))
    (function_definition
      name: (identifier)
      parameters: (parameter_list
        (parameter
          name: (identifier)
          type: (type_identifier)))
      body: (block
        (compound_assignment_expression
          left: (member_expression
            object: (identifier)
            property: (identifier))
          operator: (string)
          right: (number_literal))))))
